#!/usr/bin/env python
# encoding: utf-8

# The MIT License (MIT)

# Copyright (c) 2016-2018 CNRS

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# AUTHORS
# HervÃ© BREDIN - http://herve.niderb.fr

import sys
import os
import errno
from importlib import import_module
import numpy as np
from pyannote.core import Segment
from pyannote.core import Annotation
from pyannote.core import SlidingWindowFeature
from pyannote.core.util import string_generator
from pyannote.database import get_label_identifier


def mkdir_p(path):
    """Create directory and all its parents if they do not exist

    This is the equivalent of Unix 'mkdir -p path'

    Parameter
    ---------
    path : str
        Path to new directory.

    Reference
    ---------
    http://stackoverflow.com/questions/600268/mkdir-p-functionality-in-python
    """

    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise exc


def to_numpy(current_file, features, labels=None):
    """Convert annotation to numpy array

    Parameters
    ----------
    current_file : dict
    features : `SlidingWindowFeature` or `FeatureExtraction`
        Both `pyannote.core.SlidingWindowFeature` and
        `pyannote.audio.features.FeatureExtraction` instances are supported.
    labels : list, optional
        Predefined list of labels.  Defaults to using `annotation` labels.

    Returns
    -------
    y : numpy.ndarray
        (N, K) array where y[t, k] > 0 when labels[k] is active at timestep t.
    labels : list
        List of labels.

    See also
    --------
    See `from_numpy` to convert `y` back to a pyannote.core.Annotation instance
    """

    # imported here to avoid cyclical references
    from .features.base import FeatureExtraction
    from .features.precomputed import Precomputed
    from .features.utils import get_audio_duration

    annotation = current_file['annotation']

    # if `labels` are not provided by the user, use those in `annotation`
    if labels is None:
        labels = [get_label_identifier(label, current_file)
                  for label in annotation.labels()]
    indices = {label: i for i, label in enumerate(labels)}

    # number of samples

    if isinstance(features, SlidingWindowFeature):
        N, _ = features.data.shape

    elif isinstance(features, Precomputed):
        N, _ = features.shape(current_file)

    elif isinstance(features, FeatureExtraction):
        sw = features.sliding_window
        N = sw.samples(get_audio_duration(current_file), mode='strict')

    else:
        msg = ('`to_numpy` only supports `FeatureExtraction` and '
               '`SlidingWindowFeature` instances.')
        raise TypeError(msg)

    # number of classes
    K = len(labels)
    # one-hot encoding
    y = np.zeros((N, K), dtype=np.int64)

    sw = features.sliding_window
    for segment, _, label in annotation.itertracks(yield_label=True):
        label = get_label_identifier(label, current_file)
        try:
            k = indices[label]
        except KeyError as e:
            raise

        for i, j in sw.crop(segment, mode='center', return_ranges=True):
            i = max(0, i)
            j = min(N, j)
            y[i:j, k] += 1

    return y, labels


def from_numpy(y, precomputed, labels=None):
    """Convert numpy array to annotation

    Parameters
    ----------
    y : (N, K) or (N, ) numpy.ndarray
        When y has shape (N, K), y[t, k] > 0 means kth label is active at
        timestep t. When y has shape (N, ), y[t] = 0 means no label is active
        at timestep t, y[t] = k means (k-1)th label is active.
    precomputed : Precomputed
    labels : list, optional
        Predefined list of labels.  Defaults to labels generated by
        `pyannote.core.utils.string_generator`.

    Returns
    -------
    annotation : pyannote.core.Annotation

    See also
    --------
    `to_numpy`
    """

    window = precomputed.sliding_window

    if len(y.shape) < 2:
        N, = y.shape
        if labels is not None:
            K = len(labels)
        else:
            K = np.max(y)

        y_ = np.zeros((N, K), dtype=np.int64)
        for t, k in enumerate(y):
            if k == 0:
                continue
            y_[t, k - 1] = 1
        y = y_

    N, K = y.shape

    if labels is None:
        labels = string_generator()
        labels = [next(labels) for _ in range(K)]

    annotation = Annotation()

    y_off = np.zeros((1, K), dtype=np.int64)
    y = np.vstack((y_off, y, y_off))
    diff = np.diff(y, axis=0)
    for k, label in enumerate(labels):
        for t in np.where(diff[:, k] != 0)[0]:
            if diff[t, k] > 0:
                onset_t = window[t].middle
            else:
                segment = Segment(onset_t, window[t].middle)
                annotation[segment, k] = label

    return annotation

def get_class_by_name(class_name, default_module_name=None):
    """Load class by its name

    Parameters
    ----------
    class_name : str
    default_module_name : str, optional
        When provided and `class_name` does not contain the absolute path

    Returns
    -------
    Klass : `type`
        Class.

    Example
    -------
    >>> ClopiNet = get_class_by_name(
    ...     'pyannote.audio.embedding.models.ClopiNet')
    >>> ClopiNet = get_class_by_name(
    ...     'ClopiNet', default_module_name='pyannote.audio.embedding.models')
    """
    tokens = class_name.split('.')

    if len(tokens) == 1:
        if default_module_name is None:
            msg = (
                f'Could not infer module name from class name "{class_name}".'
                f'Please provide default module name.')
            raise ValueError(msg)
        module_name = default_module_name
    else:
        module_name = '.'.join(tokens[:-1])
        class_name = tokens[-1]

    return getattr(import_module(module_name), class_name)
